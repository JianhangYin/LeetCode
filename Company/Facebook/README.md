1. 953 Verifying an Alien Dictionary

    Brute search: 首先建立一个object，把每个字母的index存进去。然后遍历words数组，从1到length - 1。 
    然后循环遍历，每一个和前一个使用while循环进行比较。
    - 如果字典里，前一个比后一个大，结果为false。
    - 如果字典里，前一个比后一个小，退出while循环，继续遍历。
    - 如果相等，继续下一位的检验。
    - while之后，检查一下，如果后一个单词null了，但是前一个没有，还是false。

2. 301 Remove Invalid Parentheses

     这道题太难了，首先明确这道题需要写一个helper，来递归检查是不是括号有效。具体help的写好如下
     - 首先输入函数是字符串，返回值，上一个i，上一个j，和用来判断遍历方向的数组。
     - 然后从上一个i开始到字符串结尾遍历。如果是"("，值加一，是")"，值减一，如果值使用不小于零，代表从左到右，
     右括号不大于左括号，因为只要符合条件就可以continue。所以结束for循环，再求翻转的情况，如果没反转过，就
     再求翻转的，如果翻转过了，就把值添加到返回值里。
     - 如何确保返回值不重复呢？就是上一个i和上一个j的作用了。每次去除的都是连续右括号的第一个，这样子保证，去除之后
     i之前的验证值变为0，所以可以从i再开始下一轮遍历。
     - 但是为了避免两轮去掉的右括号组合一样，所以添加上一个j，每次从上一个j开始检查，可以规避这种情况。
     - 最后返回值是通过helper函数进行添加的。
     
3. 238 Product of Array Except Self
    
    这道题很有趣，不能用除法，所以直接排除了算出所有数的积，然后逐个除以i上的数这种方法。
    但是还是可以再不加入额外空间，O(n)时间内算出。
    - 首先，用一个循环算出结果数据左边所有的积，这个就是每次用前一个的结果乘以前一个的数。
    - 然后，再给每个结果数据乘上右边的积。引入一个中间值，记录i右边所有数的积，每次循环更新结果数组，
    同时也同步更新这个中间值。

4.  67 Add Binary

    这道题不是很难，但是主要有几点需要注意：
    - while语句是只要有一个没有遍历完就循环，长度短的用0替代。
    - 最后看进位项是不是0，是的话什么也不加，不是的话加1。
    
    这里面还有几个比较重要的js知识点。
    - 翻转字符串 a = a.split(""").reverse().join(""")， 转换成array翻转，再转回字符串。
    - 检验Number是不是NaN，isNaN(Number)

5. 973 K Closest Points to Origin

    这题纯粹就是考javascript里的array.sort()方法，sort里面可以放一个sort函数，input是a和b，如果返回值是负的，a在前，正的，
    b在前。
    - Math.pow(a, n) 求a的n次方
    
6. 273 Integer to English Words

    - 首先，给出三个常数，一千，百万，十亿，用作以后求整数和模。
    - 其次，建立三个数组，分别是1到19， 20到90，100。这三个数组放在一个单独的函数里，返回1000之内的值。
    - 最后在主函数里建立数组存储一千，百万，十亿。
    - 每次求num除以三个常数的整数，然后求整数的语言表达，后面加上一千或者百万或者十亿。
    - 循环三次，每次num用num和常数的模来替换。
    
    这其中用到了JavaScript求整数，求模。
    - Math.floor() 求整除
    - % 求余数
    - string.trim() 去除字符串前后的空格。

